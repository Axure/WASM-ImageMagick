import * as StackTrace from 'stacktrace-js'

// Worker loading

type CallPromise = Promise<CallResult> & { resolve?: (CallResult) => void, reject?: any }

function createCallPromise(): CallPromise {
  let resolver
  const promise = new Promise(resolve => {
    resolver = resolve
  }) as CallPromise
  promise.resolve = resolver
  return promise
}

function changeUrl(url, fileName) {
  const splitUrl = url.split('/')
  splitUrl[splitUrl.length - 1] = fileName
  return splitUrl.join('/')
}

// Heads up : instead of doing the sane code of being able to just use import.meta.url
// (Edge doesn't work) (safari mobile, chrome, opera, firefox all do) . We use stacktrace-js library to get the current file name
//
// try {
//   // @ts-ignore
//   let packageUrl = import.meta.url
//   currentJavascriptURL = packageUrl
// } catch (error) {
//   // eat
// }
const stacktrace = StackTrace.getSync()
const currentJavascriptURL = stacktrace && stacktrace[0] && stacktrace[0].fileName || './magickApi.js'
const magickWorkerUrl = changeUrl(currentJavascriptURL, 'magick.js')

let magickWorker
if (currentJavascriptURL.startsWith('http')) {
  magickWorker = new Worker(window.URL.createObjectURL(new Blob([`
  magickJsCurrentPath = '${magickWorkerUrl}'
  importScripts(magickJsCurrentPath)`
])))
}
else {
  magickWorker = new Worker(magickWorkerUrl)
}

const magickWorkerPromises: { [key: string]: CallPromise } = {}
let magickWorkerPromisesKey = 1

// handle responses as they stream in after being outputFiles by image magick
magickWorker.onmessage = e => {
  const response = e.data
  const promise = magickWorkerPromises[response.requestNumber]
  delete magickWorkerPromises[response.requestNumber]
  const result: CallResult = {
    outputFiles: response.outputFiles,
    stdout: response.stdout,
    stderr: response.stderr,
    exitCode: response.exitCode || 0,
    command: (promise as any).command,
    inputFiles: (promise as any).inputFiles,
  }
  promise.resolve(result)
}

// ImageMagick core types

/**
 * Base class for ImageMagick input and output files.
 */
export interface MagickFile {
  name: string
  /** Internal flag so some commands (virtual) can flag an (output) to be ignored by manager / UI */
  ignore?: boolean
}

/**
 * Represents output files generated when an ImageMagick command executes.
 */
export interface MagickOutputFile extends MagickFile {
  blob: Blob
}

/**
 * Represents input files that need to be provided to {@link call} or [execute](https://github.com/KnicKnic/WASM-ImageMagick/tree/master/apidocs#execute).
 *
 * Can be builded using {@link buildInputFile}
 */
export interface MagickInputFile extends MagickFile {
  content: Uint8Array
}

/**
 * The result of calling {@link call}. Also the base class of results of calling [execute](https://github.com/KnicKnic/WASM-ImageMagick/tree/master/apidocs#execute).
 */
export interface CallResult {
  /**
   * Output files generated by the command, if any
   */
  outputFiles: MagickOutputFile[]
  /**
   * Output printed by the command to stdout. For example the command `identify rose:` will print useful information to stdout
   */
  stdout: string[]
  /**
   * Output printed by the command to stderr. If `exitCode != 0` then this property could have some information about the error.
   */
  stderr: string[]
  /**
   * Exit code of the command executed. If 0 the command executed successfully, otherwise an error occurred and `stderr` could have some information about what was wrong
   */
  exitCode: number

  /** the command used for this result */
  command: string[],

  /** the input files used for this result */
  inputFiles: MagickInputFile[]
}

// call() main operation
/**
 * Low level, core, IM command execution function. All the other functions like [execute](https://github.com/KnicKnic/WASM-ImageMagick/tree/master/apidocs#execute)
 * ends up calling this one. It accept only one command and only in the form of array of strings.
 */
export function call(inputFiles: MagickInputFile[], command: string[]): Promise<CallResult> {
  const request = {
    files: inputFiles,
    args: command,
    requestNumber: magickWorkerPromisesKey,
  }
  const promise = createCallPromise();
  (promise as any).command = command;
  (promise as any).inputFiles = inputFiles
  magickWorkerPromises[magickWorkerPromisesKey] = promise

  const t0 = performance.now()
  const id = magickWorkerPromisesKey
  callListeners.forEach(listener => {
    if (listener.beforeCall) {
      listener.beforeCall({ inputFiles, command, id })
    }
  })

  promise.then(async callResult => {
    const took = performance.now() - t0
    callListeners.forEach(listener => {
      if (listener.afterCall) {
        listener.afterCall({ inputFiles, command, id, callResult, took })
      }
    })
    return callResult
  })

  magickWorker.postMessage(request)
  magickWorkerPromisesKey++

  return promise
}

/**
 * {@link call} shortcut that only returns the output files.
 */
export async function Call(inputFiles: MagickInputFile[], command: string[]): Promise<MagickOutputFile[]> {
  const result = await call(inputFiles, command)
  return result.outputFiles
}

// call() global event emitter

export interface CallEvent {
  command: string[]
  inputFiles: MagickInputFile[]
  callResult?: CallResult
  took?: number
  id: number
}

export interface CallListener {
  afterCall?(event: CallEvent): void
  beforeCall?(event: CallEvent): void
}

const callListeners: CallListener[] = []

/**
 * Adds a new call() listener notified before and after call() executes.
 */
export function addCallListener(l: CallListener) {
  callListeners.push(l)
}

export function removeAllCallListeners() {
  callListeners.splice(0, callListeners.length)
}
