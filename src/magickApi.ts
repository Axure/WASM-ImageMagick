/**
 * Base class for ImageMagick input and output files.
 */
export interface MagickFile {
  name: string
}

/**
 * Represents output files generated when an ImageMagick command executes.
 */
export interface MagickOutputFile extends MagickFile {
  blob: Blob
}

/**
 * Represents input files that need to be provided to {@link call} or [execute](https://github.com/KnicKnic/WASM-ImageMagick/tree/master/apidocs#execute).
 *
 * Can be builded using {@link buildInputFile}
 */
export interface MagickInputFile extends MagickFile {
  content: Uint8Array
}

/**
 * {@link call} shortcut that only returns the output files.
 */
export async function Call(inputFiles: MagickInputFile[], command: string[]): Promise<MagickOutputFile[]> {
  const result = await call(inputFiles, command)
  return result.outputFiles
}

/**
 * The result of calling {@link call}. Also the base class of results of calling [execute](https://github.com/KnicKnic/WASM-ImageMagick/tree/master/apidocs#execute).
 */
export interface CallResult {
  /**
   * Output files generated by the command, if any
   */
  outputFiles: MagickOutputFile[]
  /**
   * Output printed by the command to stdout. For example the command `identify rose:` will print useful information to stdout
   */
  stdout: string[]
  /**
   * Output printed by the command to stderr. If `exitCode != 0` then this property could have some information about the error.
   */
  stderr: string[]
  /**
   * Exit code of the command executed. If 0 the command executed successfully, otherwise an error occurred and `stderr` could have some information about what was wrong
   */
  exitCode: number

  /** the command used for this result */
  command: string[],

  /** the input files used for this result */
  inputFiles: MagickInputFile[]
}

/**
 * Low level execution function. All the other functions like [execute](https://github.com/KnicKnic/WASM-ImageMagick/tree/master/apidocs#execute)
 * ends up calling this one. It accept only one command and only in the form of array of strings.
 */
export function call(inputFiles: MagickInputFile[], command: string[]): Promise<CallResult> {
  const request = {
    files: inputFiles,
    args: command,
    requestNumber: magickWorkerPromisesKey,
  }
  const promise = CreatePromiseEvent();
  (promise as any).command = command;
  (promise as any).inputFiles = inputFiles
  magickWorkerPromises[magickWorkerPromisesKey] = promise

  const t0 = performance.now()
  const id = magickWorkerPromisesKey
  callListeners.forEach(listener => listener.beforeCall({ inputFiles, command, id }))

  magickWorker.postMessage(request)

  promise.then(callResult => callListeners.forEach(listener => listener.afterCall({ inputFiles, command, id, callResult, took: performance.now() - t0 })))

  magickWorkerPromisesKey++
  return promise
}

type CallPromise = Promise<CallResult> & { resolve?: (CallResult) => void, reject?: any }

function CreatePromiseEvent(): CallPromise {
  let resolver
  const promise = new Promise(resolve => {
    resolver = resolve
  }) as CallPromise
  promise.resolve = resolver
  return promise
}

const magickWorker = new Worker('magick.js')

const magickWorkerPromises: { [key: string]: CallPromise } = {}
let magickWorkerPromisesKey = 1

// handle responses as they stream in after being outputFiles by image magick
magickWorker.onmessage = e => {
  const response = e.data
  const promise = magickWorkerPromises[response.requestNumber]
  delete magickWorkerPromises[response.requestNumber]
  const result: CallResult = {
    outputFiles: response.outputFiles,
    stdout: response.stdout,
    stderr: response.stderr,
    exitCode: response.exitCode || 0,
    command: (promise as any).command,
    inputFiles: (promise as any).inputFiles,
  }
  promise.resolve(result)
}

// execute event emitter

export interface CallEvent {
  command: string[]
  inputFiles: MagickInputFile[]
  callResult?: CallResult
  took?: number
  id: number
}

export interface CallListener {
  afterCall?(event: CallEvent): void
  beforeCall?(event: CallEvent): void
}

const callListeners: CallListener[] = []

export function addCallListener(l: CallListener) {
  callListeners.push(l)
}
